#!/bin/bash
# Script to migrate svn repository to git
# https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git

set -eu

# Ignore the warning that there are better tools than `git filter-branch`
export FILTER_BRANCH_SQUELCH_WARNING=1

function usage {
  echo "usage: gitlify SUBCOMMAND [ARGS]

Subcommands:

* migrate SVN_URL [TARGET_DIR]

  Perform an initial migration from svn to git.

* prune

  Remove all empty commits in the trunk's history - in particular the
  first commit of any svn branch - and delete all svn branches that have
  been merged.

* tidy

  Reword commits.
  Currently only attempts to improve svn's autogenerated merge comments.

* track

  Track every svn branch (remotes/fcm/*) with a local git branch of the
  same name.  References are updated without setting an upstream branch,
  so the upstream could be configured for pushing to a git repository.

* resync [-t]

  Pull upstream changes from the svn repository.

  Options:
    -t  follow-up with the \`track\` subcommand
"
}

# ------------------------------

function git-dir {
  if ! git rev-parse --absolute-git-dir 2> /dev/null; then
    echo "not in a git repository"
    return 1
  fi
}

function is-bare {
  [[ $(git rev-parse --is-bare-repository 2> /dev/null) = "true" ]]
}

function get-revs {
  # Get all corresponding revision numbers, in the form r???=shorthash
  # One per line, in order from most recent revision
  git svn log --show-commit --oneline --all | cut -d'|' -f-2 | tr -d ' ' | tr '|' '='
}

function git-filter-ok {
  git_dir=$(git-dir)

  # Remove the backup refs that filter-branch automatically creates, because
  # future runs to filter-branch will refuse to run (unforced) if there is
  # already a backup.
  for r in $(git for-each-ref --format='%(refname)' refs/original); do
    git update-ref -d "$r"
  done

  # Ensure there are no lingering references
  echo "running git gc..."
  git reflog expire --expire=now --all &> /dev/null
  git gc --prune=now &> /dev/null

  if [[ $# -gt 0 ]]; then
    branches=$(git show-ref "$@" | cut -d' ' -f2)
  else
    branches=$(git for-each-ref --format='%(refname)' refs/remotes/fcm)
  fi

  echo "rebuilding git-svn references..."

  # Remove outdated git-svn references, so future git-svn commands will
  # recreate them (from the git-svn id comments in commit messages) instead of
  # failing entirely.
  for b in $branches; do
    svn="$git_dir/svn/$b"
    if [[ -d "$svn" ]]; then
      rm -rf "$svn"
    fi
  done

  # Recreate the references (from the git-svn-id comments in commit messages)
  # Not really necessary, any git-svn command will rebuild the references it
  # needs, but in doing so will spit out a list of all the revision numbers and
  # corresponding hashes and it is nice to not be randomly presented with this
  for b in $branches; do
    git svn log -1 "$b" &>/dev/null
  done
}

# --------

function parse-url {
  url=$1
  if [[ ! $url = "file://*" ]]; then
    url=$(fcm keyword-print "$url" 2>/dev/null | grep location | cut -d'=' -f2 | tr -d ' ')
    if [[ ! $url ]]; then
      echo "unrecognised fcm or svn url" >&2
      exit 1
    fi
  fi
  echo "$url"
}

function get-users {
  url=$(parse-url "$1")

  # Get list of all contributors
  if [[ ! -f users-all.txt ]]; then
    svn log "$url" --xml --quiet \
      | grep author \
      | sort -u \
      | sed -E 's/<[^>]*>//g' \
      > users-all.txt
  fi

  # Add email addresses
  # Two main methods I'm aware of:
  # - /etc/aliases - does not necessarily contain everyone, eg if the
  #   username is already the base of their email address, but the result
  #   is definitely an email address. Appears to only be missing airquser
  #   (and of course people who have since left the office)
  # - getent passwd - does contain everyone, but can only tell us the windows
  #   username, from which we cannot necessarily deduce the correct address.
  #   Appears to give apdg -> atmospheric.disperse, where we expected
  #   atmospheric.dispersion
  #
  # Most comprehensive would be check getent then /etc/aliases, but we'll just
  # check aliases because it's fine to associate airquser with the default
  # atmospheric.dispersion address.
  if [[ ! -f users-metadata.txt ]]; then
    while read name; do
      email=$(grep $name /etc/aliases | cut -d: -f2 | tr -d ' ')
      #email=$(getent passwd $name | cut -d: -f5 | sed 's/$/@metoffice.gov.uk/')
      [[ -n "$email" ]] && echo "$name = $name <$email>"
    done < users-all.txt > users-metadata.txt
  fi
}

function init {
  src=$1
  url=$(parse-url "$src")
  target=${2:-$(basename "$url")}

  # Create working directory
  [ -d "$target" ] && rm -rf "$target"
  git init "$target"

  # Add extra svn metadata to the git repository
  #
  # - --stdlayout tells git-svn to expect the trunk, branches, and tags in
  #   subdirectories of the same name within the specified repository.
  #
  # - --branches overwrites this standard layout for branches - MO-hosted fcm
  #   repositories instead have several subdirectories, of the form
  #   branches/dev/$username. We can simply match this with a glob pattern.
  #
  # - --prefix should be a prefix for the svn-tracking remotes. We overwrite
  #   the default of "origin" with "fcm" for clarity.
  #
  # - --no-metadata disables git-svn's default behaviour of adding an extra
  #   line to every commit message with an ID, which can apparently be used for
  #   syncing svn and git repositories. When fully switched to git, this is
  #   therefore unnecessary bloat.
  #   Until then however, could be useful to keep this metadata so that new
  #   commits made to the original fcm repository can be fetched without
  #   needing to do a whole ~hour long migration again. Can always remove it
  #   later (ideally *before* publishing the git repository).
  cd "$target"
  git svn init "$url" \
    --stdlayout \
    --branches='branches/dev/*/*' --branches='branches/pkg/*/*' \
    --prefix='fcm/' #--no-metadata

  # Ensure we have sufficient metadata for contributing users - creates a file
  # `users-all.txt` with a simple list of usernames, and `users-metadata.txt`
  # with names and corresponding email addresses, where possible.
  # TODO: Consider whether we want actual names included here, or if leaving
  # usernames is fine.
  get-users "$src"
  cp -p users-metadata.txt "$target/.git"
  git config svn.authorsfile .git/users-metadata.txt

  # Name of a file that can be run, with the first argument a name not in
  # authors-file, which outputs a name and email as for the authors-file.
  if [[ -x missing-name ]]; then
    cp -p missing-name "$target/.git"
    git config svn.authorsprog .git/missing-name
  fi

  # Don't let git try and make empty folders that svn was tracking
  git config svn-remote.svn.automkdirs false
}

function migrate {
  # Main migration step

  # Initialise
  init "$@"

  # Fetch everything
  git svn fetch
}

# --------
# Simple tidying

function prune-tags {
  # Tags will have been implemented as simply branches whose name happens to
  # start with "tags" (because to svn they technically are - they can be
  # committed to like any other branch). Git does have a proper concept of tags
  # that we can use instead.

  git_dir=$(git-dir)
  prefix=refs/remotes/fcm/tags
  for r in $(git for-each-ref --format='%(refname)' $prefix); do
    t=${r#$prefix/}
    echo "removing tag branch $t"

    # Create tag carefully
    # We don't overwrite an existing one, because most likely git-svn simply
    # refetched a tag that had previously been moved to a more appropriate
    # commit (be it automatically or manually).
    if ! git show-ref --verify -q "refs/tags/$t"; then
      git tag $t $r
    fi

    # Remove remote branch
    git update-ref -d $r
    # Remove git-svn ref
    svn="$git_dir/svn/$r"
    if [[ -d "$svn" ]]; then
      rm -rf "$svn"
    fi
  done
}

# Remove branches that were merged but so far not deleted
function prune-branches {
  git_dir=$(git-dir)
  prefix=refs/remotes/fcm
  for r in $(git for-each-ref --format='%(refname)' --merged=fcm/trunk $prefix); do
    # Explicitly ignore the trunk because it always counts as merged, but we do
    # need it.
    if [[ $r = *trunk ]]; then
      continue
    fi

    b=${r#$prefix/}
    echo "removing merged branch $b"

    # Delete local branch of the same name, if present
    if git show-ref --verify -q "refs/heads/$b"; then
      git br -D $b
    fi

    # Remove remote branch
    git update-ref -d $r
    # Remove git-svn ref
    svn="$git_dir/svn/$r"
    if [[ -d "$svn" ]]; then
      rm -rf "$svn"
    fi
  done
}

# Remove empty commits
#
# The first commit of an svn branch is simply taking a copy of the trunk at
# that point, which as far as git is concerned are empty commits, and best
# removed. This does not break the link between git and svn: git-svn can
# restore metadata from git-svn-id references in commit messages. However,
# there is a risk of re-retrieving the pruned commits.
function prune-commits {
  # Handle options - references to include and exclude
  # Default to everything
  branches=""
  revs="--all"
  if [[ $# -gt 0 ]]; then
    exclude=
    OPTIND=1
    while getopts ':x:' opt; do
      case $opt in
        x) exclude="$OPTARG";;
      esac
    done
    shift $(( OPTIND-1 ))

    # Select all branches made since the excluded commit
    branches=$(git for-each-ref --format='%(refname)' --contains="$exclude")
    revs="--tags $branches ^$exclude"
  fi

  # Define a filter that removes empty commits, but only if already integrated
  # into the trunk, or tagged
  cfilter='
    if git merge-base --is-ancestor "$GIT_COMMIT" remotes/fcm/trunk; then
      git_commit_non_empty_tree "$@"
    elif [[ $(git for-each-ref --points-at="$GIT_COMMIT" refs/tags) ]]; then
      git_commit_non_empty_tree "$@"
    else
      git commit-tree "$@"
    fi
  '
  git filter-branch \
    --commit-filter "$cfilter" \
    --tag-name-filter cat \
    -- $revs
  git-filter-ok $branches
}

function prune {
  prune-tags
  prune-branches
  prune-commits "$@"
}

# --------

# Bonus: bespoke tidying
# A repository migration is the one opportunity we get to review the general
# state of the repository, for example the format and consistency of commit
# messages, and purging files that shouldn't really have been under version
# control in the first place (like built documentation or test output).
#
# Probably not going to be worth the effort, but here are a few functions to
# at least investigate it.

# Get all commit messages, separated by dashes for easy parsing
function get-msgs {
  git log --format='%h%n%B%n--------'
}

# Remove svn's merge messages
function rewrite-merges {
  # If it occurs on the second line or later (2,$), remove it. Otherwise, it is
  # almost certainly the entire commit message (except possibly a git-svn id),
  # so replace it with simply the message "Merge changes".
  git filter-branch \
    --msg-filter "sed -E '/Merged into/{2,\$d; s/.*/Merge changes/}'" \
    -- --all && git-filter-ok
}

# Rename authors
function reauthor {
  old_name=$1
  new_name=$2
  new_email=$3
  git filter-branch --env-filter "
if [ \"\$GIT_COMMITTER_NAME\" = \"$old_name\" ]; then
    export GIT_COMMITTER_NAME=$new_name
    export GIT_COMMITTER_EMAIL=$new_email
fi
if [ \"\$GIT_AUTHOR_NAME\" = \"$old_name\" ]; then
    export GIT_AUTHOR_NAME=$new_name
    export GIT_AUTHOR_EMAIL=$new_email
fi
" --tag-name-filter cat -- --all && git-filter-ok
}

# Remove files
function remove {
  cmd="rm $@"
  echo "running '$cmd' on all commits"
  set -x
  git filter-branch \
    --prune-empty --tree-filter "$cmd" \
    -- --all && git-filter-ok
}

function tidy {
  rewrite-merges
}

# --------

# Update local versions of branches
function track {
  current=$(git symbolic-ref --short HEAD)
  for r in $(git for-each-ref --format='%(refname)' refs/remotes/fcm); do
    b=${r#refs/remotes/fcm/}  # Short ref
    if [[ $current = $b ]]; then
      if is-bare; then
        git reset -q --soft $r
      else
        git reset -q --hard $r
      fi
    else
      git branch -f $b $r
    fi
  done
}

function resync {
  # Handle options
  track=
  OPTIND=1
  while getopts 't' opt; do
    case $opt in
      t) track="yes";;
    esac
  done
  shift $(( OPTIND-1 ))

  old_rev=$(git svn find-rev fcm/trunk)
  old_head=$(git rev-parse fcm/trunk)
  old_time=$(git show -s --format='@%ct' fcm/trunk)

  # Fetch everything from the most recent trunk we know about to now
  echo "fetching r$old_rev onwards"
  git svn fetch -r$old_rev:HEAD

  new_head=$(git rev-parse fcm/trunk)

  prune-tags
  prune-branches
  if [[ $old_head != $new_head ]]; then
    prune-commits -x $old_head
  fi

  if [[ $track ]]; then
    track
  fi
}

# --------

function un-remote {
  # Make regular branches instead of the remotes that git-svn creates
  for b in $(git for-each-ref --format='%(refname:short)' refs/remotes/fcm); do
    git branch $b refs/remotes/$b && git branch -D -r $b
  done
}

function un-svn {
  # Remove all git-svn metadata
  git filter-branch --msg-filter 'head -n -3' && git-filter-ok
  # Remove config
  git config --remove-section svn
  git config --remove-section svn-remote.svn
}

function push {
  # Set up new remotes for hosting with git
  name=$1
  git remote add origin git@github.com:$name.git
  git push origin main --tags #--all
}

# ------------------------------

subcommand="-h"
if [[ $# -gt 0 ]]; then
  subcommand="$1"
  shift 1
fi

case $subcommand in
  help|--help|-h)
    usage
    exit
    ;;

  get-revs) ;&
  git-filter-ok) ;&

  parse-url) ;&
  get-users) ;&
  init) ;&
  migrate) ;&

  prune-tags) ;&
  prune-branches) ;&
  prune-commits) ;&
  prune) ;&

  get-msgs) ;&
  rewrite-merges) ;&
  reauthor) ;&
  remove) ;&
  tidy) ;&

  track) ;&
  resync) ;&

  un-remote) ;&
  un-svn) ;&
  push) $subcommand "$@" ;;

  *)
    usage
    exit 1
    ;;
esac
